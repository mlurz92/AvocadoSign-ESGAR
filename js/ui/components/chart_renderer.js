window.chartRenderer = (() => {

    // Chart-Cache für Performance-Optimierung
    const _chartCache = new Map(); // Speichert Chart-Daten-Hashes
    const _svgContainers = new Map(); // Speichert SVG-Referenzen

    // Hash-Funktion für Chart-Daten (einfache Implementierung)
    function _hashData(data) {
        if (!data) return null;
        try {
            return JSON.stringify(data);
        } catch (e) {
            return null;
        }
    }

    // Prüfe ob sich Chart-Daten geändert haben
    function _hasDataChanged(targetElementId, newData) {
        const cachedHash = _chartCache.get(targetElementId);
        const newHash = _hashData(newData);
        return cachedHash !== newHash;
    }

    // Speichere Chart-Daten im Cache
    function _cacheChartData(targetElementId, data) {
        const hash = _hashData(data);
        if (hash) {
            _chartCache.set(targetElementId, hash);
        }
    }

    // Lösche Cache für spezifischen Chart oder alle
    function clearChartCache(targetElementId) {
        if (targetElementId) {
            _chartCache.delete(targetElementId);
            _svgContainers.delete(targetElementId);
        } else {
            _chartCache.clear();
            _svgContainers.clear();
        }
    }

    function createSvgContainer(targetElementId, options = {}) {
        const container = d3.select(`#${targetElementId}`);
        if (container.empty() || !container.node()) { return null; }
        container.selectAll("svg").remove();
        container.html('');

        const containerNode = container.node();
        const initialWidth = containerNode.clientWidth || 0;
        const initialHeight = containerNode.clientHeight || 0;
        const margin = { ...window.APP_CONFIG.CHART_SETTINGS.DEFAULT_MARGIN, ...(options.margin || {}) };
        const width = options.width || (initialWidth > 20 ? initialWidth : window.APP_CONFIG.CHART_SETTINGS.DEFAULT_WIDTH);
        let height = options.height || (initialHeight > 20 ? initialHeight : window.APP_CONFIG.CHART_SETTINGS.DEFAULT_HEIGHT);

        const legendItemCount = options.legendItemCount || 0;
        const estimatedLegendHeight = options.legendBelow ? Math.max(25, legendItemCount * 12 + 15) : 0;
        if (options.useCompactMargins && options.legendBelow) {
            height = Math.max(height, (options.height || window.APP_CONFIG.CHART_SETTINGS.DEFAULT_HEIGHT) + estimatedLegendHeight);
        }

        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom - estimatedLegendHeight;

        if (innerWidth <= 20 || innerHeight <= 20) {
            container.html('<p class="text-muted small text-center p-2">Chart size invalid or too small.</p>');
            return null;
        }

        const svg = container.append("svg")
            .attr("viewBox", `0 0 ${width} ${height}`)
            .attr("preserveAspectRatio", "xMidYMid meet")
            .style("width", "100%").style("height", "100%").style("max-width", `${width}px`)
            .style("background-color", options.backgroundColor || window.APP_CONFIG.CHART_SETTINGS.PLOT_BACKGROUND_COLOR)
            .style("font-family", "var(--font-family-sans-serif)").style("overflow", "visible");

        const chartArea = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`).attr("class", "chart-area");
        return { svg, chartArea, width, height, innerWidth, innerHeight, margin, legendSpaceY: estimatedLegendHeight };
    }

    function createTooltip() {
        let tooltip = d3.select("body").select(".chart-tooltip");
        if (tooltip.empty()) {
            tooltip = d3.select("body").append("div").attr("class", "chart-tooltip")
                .style("opacity", 0).style("position", "absolute").style("pointer-events", "none")
                .style("background", "rgba(33, 37, 41, 0.95)").style("color", "#fff").style("padding", "8px 12px")
                .style("border-radius", "4px").style("font-size", window.APP_CONFIG.CHART_SETTINGS.TOOLTIP_FONT_SIZE).style("z-index", "3050")
                .style("line-height", "1.4").style("transition", `opacity ${window.APP_CONFIG.UI_SETTINGS.TRANSITION_DURATION_MS / 2}ms ease-out`)
                .style("box-shadow", "0 4px 6px rgba(0,0,0,0.1)");
        }
        return tooltip;
    }

    // --- CHART IMPLEMENTATIONS ---

    function renderAgeDistributionChart(ageData, targetElementId, options = {}) {
        // Prüfe ob sich Daten geändert haben (Performance-Optimierung)
        if (!_hasDataChanged(targetElementId, ageData) && !options.forceRender) {
            return; // Kein Update nötig
        }

        const setupOptions = { ...options, margin: { ...window.APP_CONFIG.CHART_SETTINGS.DEFAULT_MARGIN, ...options.margin } };
        const containerSetup = createSvgContainer(targetElementId, setupOptions);
        if (!containerSetup) return;
        const { svg, chartArea, innerWidth, innerHeight, width, height, margin } = containerSetup;
        const tooltip = createTooltip();
        const barColor = window.APP_CONFIG.CHART_SETTINGS.AS_COLOR;
        
        // Cache die Daten
        _cacheChartData(targetElementId, ageData);
        
        // Animation nur beim ersten Render oder wenn erzwungen
        const animationDuration = options.skipAnimation ? 0 : window.APP_CONFIG.CHART_SETTINGS.ANIMATION_DURATION_MS;

        if (!Array.isArray(ageData) || ageData.length === 0) {
            chartArea.append('text').attr('x', innerWidth / 2).attr('y', innerHeight / 2).attr('text-anchor', 'middle').attr('class', 'text-muted small').text('No age data available.');
            return;
        }

        const validData = ageData.filter(d => !isNaN(d) && isFinite(d));
        const xMin = d3.min(validData);
        const xMax = d3.max(validData);
        const xDomain = [Math.max(0, xMin - 5), xMax + 5];
        
        const x = d3.scaleLinear().domain(xDomain).nice().range([0, innerWidth]);
        const tickCountX = Math.max(3, Math.min(10, Math.floor(innerWidth / 50)));
        
        chartArea.append("g").attr("class", "x-axis axis")
            .attr("transform", `translate(0,${innerHeight})`)
            .call(d3.axisBottom(x).ticks(tickCountX).tickSizeOuter(0).tickFormat(d3.format("d")))
            .selectAll("text").style("font-size", window.APP_CONFIG.CHART_SETTINGS.TICK_LABEL_FONT_SIZE);
        
        svg.append("text").attr("class", "axis-label x-axis-label")
            .attr("text-anchor", "middle").attr("x", margin.left + innerWidth / 2).attr("y", height - 5)
            .style("font-size", window.APP_CONFIG.CHART_SETTINGS.AXIS_LABEL_FONT_SIZE)
            .text(window.APP_CONFIG.UI_TEXTS.axisLabels.age);

        const histogram = d3.histogram().value(d => d).domain(x.domain()).thresholds(x.ticks(Math.max(5, Math.min(20, Math.floor(innerWidth / 25)))));
        const bins = histogram(validData);
        
        const yMax = d3.max(bins, d => d.length);
        const y = d3.scaleLinear().range([innerHeight, 0]).domain([0, yMax > 0 ? yMax : 1]).nice();
        const tickCountY = Math.max(2, Math.min(6, Math.floor(innerHeight / 35)));
        
        chartArea.append("g").attr("class", "y-axis axis")
            .call(d3.axisLeft(y).ticks(tickCountY).tickSizeOuter(0).tickFormat(d3.format("d")))
            .selectAll("text").style("font-size", window.APP_CONFIG.CHART_SETTINGS.TICK_LABEL_FONT_SIZE);
        
        svg.append("text").attr("class", "axis-label y-axis-label")
            .attr("text-anchor", "middle").attr("transform", `translate(${margin.left / 2 - 5}, ${margin.top + innerHeight / 2}) rotate(-90)`)
            .style("font-size", window.APP_CONFIG.CHART_SETTINGS.AXIS_LABEL_FONT_SIZE)
            .text(window.APP_CONFIG.UI_TEXTS.axisLabels.patientCount);

        if (window.APP_CONFIG.CHART_SETTINGS.ENABLE_GRIDLINES) {
            chartArea.append("g").attr("class", "grid y-grid").call(d3.axisLeft(y).ticks(tickCountY).tickSize(-innerWidth).tickFormat(""));
        }

        chartArea.selectAll(".bar").data(bins).join("rect")
            .attr("class", "bar")
            .attr("x", d => x(d.x0) + 1)
            .attr("y", y(0))
            .attr("width", d => Math.max(0, x(d.x1) - x(d.x0) - 1))
            .attr("height", 0)
            .style("fill", barColor)
            .style("opacity", 0.8)
            .attr("rx", 1).attr("ry", 1)
            .on("mouseover", (event, d) => {
                tooltip.transition().duration(50).style("opacity", .95);
                tooltip.html(`Age: ${d.x0}-${d.x1}<br>Count: ${d.length}`)
                    .style("left", (event.pageX + 10) + "px").style("top", (event.pageY - 15) + "px");
                d3.select(event.currentTarget).style("opacity", 1).style("stroke", "#333").style("stroke-width", 0.5);
            })
            .on("mouseout", (event) => {
                tooltip.transition().duration(200).style("opacity", 0);
                d3.select(event.currentTarget).style("opacity", 0.8).style("stroke", "none");
            })
            .transition().duration(animationDuration).ease(d3.easeCubicOut)
            .attr("y", d => y(d.length))
            .attr("height", d => Math.max(0, innerHeight - y(d.length)));
    }

    function renderPieChart(data, targetElementId, options = {}) {
        // Prüfe ob sich Daten geändert haben (Performance-Optimierung)
        if (!_hasDataChanged(targetElementId, data) && !options.forceRender) {
            return; // Kein Update nötig
        }
        
        const setupOptions = { ...options, margin: options.useCompactMargins ? { ...window.APP_CONFIG.CHART_SETTINGS.COMPACT_PIE_MARGIN, ...options.margin } : { ...window.APP_CONFIG.CHART_SETTINGS.DEFAULT_MARGIN, ...options.margin }, legendBelow: options.legendBelow ?? options.useCompactMargins, legendItemCount: data?.length || 0 };
        const containerSetup = createSvgContainer(targetElementId, setupOptions);
        if (!containerSetup) return;
        const { svg, chartArea, innerWidth, innerHeight, margin, legendSpaceY } = containerSetup;
        const tooltip = createTooltip();
        const colorScheme = [window.APP_CONFIG.CHART_SETTINGS.AS_COLOR, window.APP_CONFIG.CHART_SETTINGS.T2_COLOR, window.APP_CONFIG.CHART_SETTINGS.N_NEG_COLOR, window.APP_CONFIG.CHART_SETTINGS.N_POS_COLOR];
        const validData = data.filter(d => d && typeof d.value === 'number' && d.value >= 0 && typeof d.label === 'string');
        const totalValue = d3.sum(validData, d => d.value);
        
        // Cache die Daten
        _cacheChartData(targetElementId, data);
        
        // Animation nur beim ersten Render oder wenn erzwungen
        const animationDuration = options.skipAnimation ? 0 : window.APP_CONFIG.CHART_SETTINGS.ANIMATION_DURATION_MS;

        if (validData.length === 0 || totalValue <= 0) {
            chartArea.append('text').attr('x', innerWidth / 2).attr('y', innerHeight / 2).attr('text-anchor', 'middle').attr('class', 'text-muted small').text('No data available.');
            return;
        }

        const outerRadius = Math.min(innerWidth, innerHeight) / 2 * (options.outerRadiusFactor ?? 0.9);
        const innerRadius = outerRadius * (options.innerRadiusFactor ?? 0.5);
        if (outerRadius <= innerRadius || outerRadius <= 0) {
            chartArea.append('text').attr('x', innerWidth / 2).attr('y', innerHeight / 2).attr('text-anchor', 'middle').attr('class', 'text-muted small').text('Chart too small');
            return;
        }

        const color = d3.scaleOrdinal().domain(validData.map(d => d.label)).range(colorScheme);
        const pie = d3.pie().value(d => d.value).sort(null);
        const arcGenerator = d3.arc().innerRadius(innerRadius).outerRadius(outerRadius).cornerRadius(options.cornerRadius ?? 2);

        const pieGroup = chartArea.append("g").attr("class", "pie-group").attr("transform", `translate(${innerWidth / 2},${innerHeight / 2})`);
        const arcs = pieGroup.selectAll(".arc").data(pie(validData)).join("g").attr("class", "arc");

        arcs.append("path")
            .style("fill", d => color(d.data.label))
            .style("stroke", window.APP_CONFIG.CHART_SETTINGS.PLOT_BACKGROUND_COLOR)
            .style("stroke-width", "1.5px")
            .style("opacity", 0.85)
            .on("mouseover", function(event, d) {
                tooltip.transition().duration(50).style("opacity", .95);
                tooltip.html(`<strong>${d.data.label}:</strong> ${formatNumber(d.data.value, 0)} (${formatPercent(d.data.value / totalValue, 1)})`)
                    .style("left", (event.pageX + 10) + "px").style("top", (event.pageY - 15) + "px");
                d3.select(this).transition().duration(100).style("opacity", 1).attr("transform", "scale(1.03)");
            })
            .on("mouseout", function() {
                tooltip.transition().duration(200).style("opacity", 0);
                d3.select(this).transition().duration(100).style("opacity", 0.85).attr("transform", "scale(1)");
            })
            .transition().duration(animationDuration).ease(d3.easeCubicOut)
            .attrTween("d", d => {
                const i = d3.interpolate({startAngle: d.startAngle, endAngle: d.startAngle}, d);
                return t => arcGenerator(i(t));
            });
        
        if (setupOptions.legendBelow && legendSpaceY > 0) {
            const legendGroup = svg.append("g").attr("class", "legend pie-legend")
                .attr("transform", `translate(${margin.left}, ${margin.top + innerHeight + 15})`)
                .attr("font-size", window.APP_CONFIG.CHART_SETTINGS.LEGEND_FONT_SIZE).attr("text-anchor", "start");
            
            let currentX = 0; 
            let currentY = 0;
            const legendItems = legendGroup.selectAll("g.legend-item").data(validData).join("g").attr("class", "legend-item");
            
            legendItems.each(function(d, i) {
                const item = d3.select(this);
                item.append("rect").attr("x", 0).attr("y", 0).attr("width", 10).attr("height", 10).attr("fill", color(d.label));
                item.append("text").attr("x", 14).attr("y", 5).attr("dy", "0.35em").text(`${d.label} (${formatNumber(d.value, 0)})`);
                const itemWidth = this.getBBox().width + 15;
                if (i > 0 && currentX + itemWidth > innerWidth) { currentX = 0; currentY += 18; }
                item.attr("transform", `translate(${currentX}, ${currentY})`);
                currentX += itemWidth;
            });
        }
    }

    function renderComparisonBarChart(chartData, targetElementId, options = {}, t2Label = 'T2') {
        // Prüfe ob sich Daten geändert haben (Performance-Optimierung)
        if (!_hasDataChanged(targetElementId, chartData) && !options.forceRender) {
            return; // Kein Update nötig
        }
        
        const setupOptions = { ...options, margin: { top: 20, right: 20, bottom: 60, left: 50, ...options.margin } };
        const containerSetup = createSvgContainer(targetElementId, setupOptions);
        if (!containerSetup) return;
        const { svg, chartArea, innerWidth, innerHeight, margin, height } = containerSetup;
        const tooltip = createTooltip();
        
        // Cache die Daten
        _cacheChartData(targetElementId, chartData);
        
        // Animation nur beim ersten Render oder wenn erzwungen
        const animationDuration = options.skipAnimation ? 0 : window.APP_CONFIG.CHART_SETTINGS.ANIMATION_DURATION_MS;
        
        if (!Array.isArray(chartData) || chartData.length === 0) {
            chartArea.append('text').attr('x', innerWidth / 2).attr('y', innerHeight / 2).attr('text-anchor', 'middle').attr('class', 'text-muted small').text('No comparison data.');
            return;
        }
        
        const groups = chartData.map(d => d.metric);
        const subgroups = Object.keys(chartData[0]).filter(key => key !== 'metric');
        const subgroupDisplayNames = { 'AS': window.APP_CONFIG.UI_TEXTS.legendLabels.avocadoSign, 'T2': t2Label };
        
        const x0 = d3.scaleBand().domain(groups).range([0, innerWidth]).paddingInner(0.35);
        const x1 = d3.scaleBand().domain(subgroups).range([0, x0.bandwidth()]).padding(0.15);
        const y = d3.scaleLinear().domain([0, 1.0]).nice().range([innerHeight, 0]);
        const color = d3.scaleOrdinal().domain(subgroups).range([window.APP_CONFIG.CHART_SETTINGS.AS_COLOR, window.APP_CONFIG.CHART_SETTINGS.T2_COLOR]);
        
        chartArea.append("g").attr("class", "y-axis axis").call(d3.axisLeft(y).ticks(5, "%").tickSizeOuter(0))
            .selectAll("text").style("font-size", window.APP_CONFIG.CHART_SETTINGS.TICK_LABEL_FONT_SIZE);
        
        svg.append("text").attr("class", "axis-label y-axis-label").attr("text-anchor", "middle")
            .attr("transform", `translate(${margin.left / 2}, ${margin.top + innerHeight / 2}) rotate(-90)`)
            .style("font-size", window.APP_CONFIG.CHART_SETTINGS.AXIS_LABEL_FONT_SIZE).text(window.APP_CONFIG.UI_TEXTS.axisLabels.metricValue);
        
        chartArea.append("g").attr("class", "x-axis axis").attr("transform", `translate(0,${innerHeight})`)
            .call(d3.axisBottom(x0).tickSizeOuter(0)).selectAll(".tick text")
            .style("text-anchor", "middle").style("font-size", window.APP_CONFIG.CHART_SETTINGS.TICK_LABEL_FONT_SIZE);
        
        if (window.APP_CONFIG.CHART_SETTINGS.ENABLE_GRIDLINES) {
            chartArea.append("g").attr("class", "grid y-grid").call(d3.axisLeft(y).ticks(5).tickSize(-innerWidth).tickFormat(""));
        }
        
        const metricGroup = chartArea.selectAll(".metric-group").data(chartData).join("g")
            .attr("class", "metric-group").attr("transform", d => `translate(${x0(d.metric)},0)`);
        
        metricGroup.selectAll("rect").data(d => subgroups.map(key => ({key: key, value: d[key], metric: d.metric})))
            .join("rect").attr("class", d => `bar bar-${d.key.toLowerCase()}`)
            .attr("x", d => x1(d.key)).attr("y", y(0))
            .attr("width", x1.bandwidth()).attr("height", 0)
            .attr("fill", d => color(d.key)).style("opacity", 0.9).attr("rx", 1).attr("ry", 1)
            .on("mouseover", function(event, d) {
                tooltip.transition().duration(50).style("opacity", .95);
                const displayName = subgroupDisplayNames[d.key] || d.key;
                const isRate = d.metric !== 'AUC' && d.metric !== 'F1';
                const digits = isRate ? 0 : 3;
                const formattedValue = isRate ? formatPercent(d.value, digits) : formatNumber(d.value, digits);
                tooltip.html(`<strong>${d.metric} (${displayName}):</strong> ${formattedValue}`)
                    .style("left", (event.pageX + 10) + "px").style("top", (event.pageY - 15) + "px");
                d3.select(this).style("opacity", 1).style("stroke", "#333").style("stroke-width", 1);
            })
            .on("mouseout", function() {
                tooltip.transition().duration(200).style("opacity", 0);
                d3.select(this).style("opacity", 0.9).style("stroke", "none");
            })
            .transition().duration(animationDuration).ease(d3.easeCubicOut)
            .attr("y", d => y(d.value ?? 0)).attr("height", d => Math.max(0, innerHeight - y(d.value ?? 0)));
        
        const legendGroup = svg.append("g").attr("class", "legend bar-legend")
            .attr("font-size", window.APP_CONFIG.CHART_SETTINGS.LEGEND_FONT_SIZE).attr("text-anchor", "start");
        const legendItems = legendGroup.selectAll("g.legend-item").data(subgroups).join("g").attr("class", "legend-item");
        
        let totalLegendWidth = 0; const legendSpacings = [];
        legendItems.append("rect").attr("x", 0).attr("y", -5).attr("width", 10).attr("height", 10).attr("fill", color);
        legendItems.append("text").attr("x", 14).attr("y", 0).attr("dy", "0.35em").text(d => subgroupDisplayNames[d] || d)
            .each(function() {
                const w = this.getBBox().width + 25;
                legendSpacings.push(w);
                totalLegendWidth += w;
            });
        
        const legendStartX = margin.left + Math.max(0, (innerWidth - totalLegendWidth) / 2);
        let currentX = legendStartX;
        legendItems.attr("transform", (d, i) => {
            const tx = currentX;
            currentX += legendSpacings[i];
            return `translate(${tx}, ${height - margin.bottom + 30})`;
        });
    }

    function renderDiagnosticPerformanceChart(data, predictionKey, referenceKey, targetElementId, methodName) {
        const setupOptions = { margin: { top: 30, right: 40, bottom: 50, left: 70 } };
        const containerSetup = createSvgContainer(targetElementId, setupOptions);
        if (!containerSetup) return;
        const { svg, chartArea, innerWidth, innerHeight, margin } = containerSetup;
        const tooltip = createTooltip();

        const performance = window.statisticsService.calculateDiagnosticPerformance(data, predictionKey, referenceKey);
        if (!performance || !isFinite(performance.sens?.value) || !isFinite(performance.spec?.value)) {
            chartArea.append('text').attr('x', innerWidth / 2).attr('y', innerHeight / 2).attr('text-anchor', 'middle').attr('class', 'text-muted small').text('No valid data for ROC chart.');
            return;
        }

        const sensitivity = performance.sens.value;
        const specificity = performance.spec.value;
        const oneMinusSpecificity = 1 - specificity;
        const auc = performance.auc.value;

        const x = d3.scaleLinear().domain([0, 1]).range([0, innerWidth]);
        const y = d3.scaleLinear().domain([0, 1]).range([innerHeight, 0]);

        chartArea.append("g").attr("class", "x-axis axis").attr("transform", `translate(0,${innerHeight})`)
            .call(d3.axisBottom(x).ticks(5).tickFormat(d3.format(".1f")))
            .selectAll("text").style("font-size", window.APP_CONFIG.CHART_SETTINGS.TICK_LABEL_FONT_SIZE);
        
        svg.append("text").attr("class", "axis-label x-axis-label").attr("text-anchor", "middle")
            .attr("x", margin.left + innerWidth / 2).attr("y", innerHeight + margin.top + 30)
            .style("font-size", window.APP_CONFIG.CHART_SETTINGS.AXIS_LABEL_FONT_SIZE).text(window.APP_CONFIG.UI_TEXTS.axisLabels.oneMinusSpecificity);

        chartArea.append("g").attr("class", "y-axis axis").call(d3.axisLeft(y).ticks(5).tickFormat(d3.format(".1f")))
            .selectAll("text").style("font-size", window.APP_CONFIG.CHART_SETTINGS.TICK_LABEL_FONT_SIZE);
        
        svg.append("text").attr("class", "axis-label y-axis-label").attr("text-anchor", "middle")
            .attr("transform", `translate(${margin.left / 2 - 10}, ${margin.top + innerHeight / 2}) rotate(-90)`)
            .style("font-size", window.APP_CONFIG.CHART_SETTINGS.AXIS_LABEL_FONT_SIZE).text(window.APP_CONFIG.UI_TEXTS.axisLabels.sensitivity);

        if (window.APP_CONFIG.CHART_SETTINGS.ENABLE_GRIDLINES) {
            chartArea.append("g").attr("class", "grid x-grid").attr("transform", `translate(0,${innerHeight})`)
                .call(d3.axisBottom(x).ticks(5).tickSize(-innerHeight).tickFormat(""));
            chartArea.append("g").attr("class", "grid y-grid").call(d3.axisLeft(y).ticks(5).tickSize(-innerWidth).tickFormat(""));
        }

        chartArea.append("line").attr("class", "reference-line").attr("x1", x(0)).attr("y1", y(0)).attr("x2", x(1)).attr("y2", y(1))
            .style('stroke', '#adb5bd').style('stroke-width', 1).style('stroke-dasharray', '4 2');

        const rocLine = d3.line().x(d => x(d[0])).y(d => y(d[1])).curve(d3.curveMonotoneX);
        const dataPoints = [[0, 0], [oneMinusSpecificity, sensitivity], [1, 1]];

        chartArea.append("path").datum(dataPoints).attr("class", "roc-curve").attr("fill", "none")
            .attr("stroke", window.APP_CONFIG.CHART_SETTINGS.AS_COLOR).attr("stroke-width", 2).attr('d', rocLine);

        const circle = chartArea.append("circle").attr("cx", x(oneMinusSpecificity)).attr("cy", y(sensitivity)).attr("r", 5)
            .attr("fill", window.APP_CONFIG.CHART_SETTINGS.AS_COLOR)
            .on("mouseover", (event) => {
                tooltip.transition().duration(50).style("opacity", .95);
                tooltip.html(`<strong>${methodName}</strong><br>Sensitivity: ${formatPercent(sensitivity, 1)}<br>1-Specificity: ${formatPercent(oneMinusSpecificity, 1)}<br>AUC: ${formatNumber(auc, 3)}`)
                    .style("left", (event.pageX + 10) + "px").style("top", (event.pageY - 15) + "px");
                 d3.select(event.currentTarget).transition().duration(100).attr('r', 7);
            })
            .on("mouseout", (event) => {
                tooltip.transition().duration(200).style("opacity", 0);
                d3.select(event.currentTarget).transition().duration(100).attr('r', 5);
            });

        chartArea.append("text").attr("class", "auc-label").attr("x", innerWidth - 5).attr("y", innerHeight - 5)
            .attr("text-anchor", "end").style("font-size", "12px").style("font-weight", "bold")
            .text(`AUC: ${formatNumber(auc, 3)}`);
    }
    
    function renderFeatureImportanceChart(data, targetElementId, options = {}) {
        const setupOptions = { ...options, margin: { top: 20, right: 20, bottom: 40, left: 180, ...options.margin } };
        const containerSetup = createSvgContainer(targetElementId, setupOptions);
        if (!containerSetup) return;
        const { svg, chartArea, innerWidth, innerHeight, width, height, margin } = containerSetup;
        const tooltip = createTooltip();
    
        const validData = (Array.isArray(data) ? data : [])
            .filter(d => d.or && isFinite(d.or.value) && d.or.ci && isFinite(d.or.ci.lower) && isFinite(d.or.ci.upper))
            .sort((a, b) => b.or.value - a.or.value);
            
        if (validData.length === 0) {
             chartArea.append('text').attr('x', innerWidth / 2).attr('y', innerHeight / 2).attr('text-anchor', 'middle').attr('class', 'text-muted small').text('No feature association data available.');
            return;
        }
    
        const y = d3.scaleBand().range([0, innerHeight]).domain(validData.map(d => d.featureName)).padding(0.4);
    
        chartArea.append("g").attr("class", "y-axis axis").call(d3.axisLeft(y).tickSize(0).tickPadding(10))
            .selectAll("text").style("font-size", window.APP_CONFIG.CHART_SETTINGS.TICK_LABEL_FONT_SIZE);
    
        const xMin = d3.min(validData, d => d.or.ci.lower);
        const xMax = d3.max(validData, d => d.or.ci.upper);
        const domainMin = Math.max(0.1, xMin > 1 ? 0.5 : xMin * 0.8);
        const domainMax = Math.min(50, xMax * 1.2);
        
        const x = d3.scaleLog().domain([domainMin, domainMax]).range([0, innerWidth]);
        const tickValues = [0.1, 0.2, 0.5, 1, 2, 5, 10, 20, 50].filter(v => v >= domainMin && v <= domainMax);

        chartArea.append("g").attr("class", "x-axis axis").attr("transform", `translate(0, ${innerHeight})`)
            .call(d3.axisBottom(x).tickValues(tickValues).tickFormat(d3.format("~g")).tickSizeOuter(0))
            .selectAll("text").style("font-size", window.APP_CONFIG.CHART_SETTINGS.TICK_LABEL_FONT_SIZE);
    
        svg.append("text").attr("class", "axis-label x-axis-label").attr("text-anchor", "middle").attr("x", margin.left + innerWidth / 2).attr("y", height - 5)
            .style("font-size", window.APP_CONFIG.CHART_SETTINGS.AXIS_LABEL_FONT_SIZE)
            .text(window.APP_CONFIG.UI_TEXTS.insightsTab.featureImportance.chartXAxisLabel);

        if (window.APP_CONFIG.CHART_SETTINGS.ENABLE_GRIDLINES) {
            chartArea.append("g").attr("class", "grid x-grid").call(d3.axisBottom(x).tickValues(tickValues).tickSize(-innerHeight).tickFormat(""));
        }
    
        chartArea.append("line").attr("x1", x(1)).attr("x2", x(1)).attr("y1", 0).attr("y2", innerHeight)
            .attr("stroke", "#6c757d").attr("stroke-width", 1.5).attr("stroke-dasharray", "3,3");
    
        const featureGroup = chartArea.selectAll(".feature-group").data(validData).join("g")
            .attr("class", "feature-group").attr("transform", d => `translate(0, ${y(d.featureName)})`);

        featureGroup.append("line").attr("class", "ci-line")
            .attr("x1", d => x(d.or.ci.lower)).attr("x2", d => x(d.or.ci.upper))
            .attr("y1", y.bandwidth() / 2).attr("y2", y.bandwidth() / 2)
            .attr("stroke", "#6c757d").attr("stroke-width", 1);
    
        featureGroup.selectAll(".ci-cap").data(d => [d.or.ci.lower, d.or.ci.upper]).join("line").attr("class", "ci-cap")
            .attr("x1", d => x(d)).attr("x2", d => x(d))
            .attr("y1", y.bandwidth() / 2 - 4).attr("y2", y.bandwidth() / 2 + 4)
            .attr("stroke", "#6c757d").attr("stroke-width", 1);
    
        featureGroup.append("rect").attr("class", "or-point")
            .attr("x", d => x(d.or.value) - 4).attr("y", y.bandwidth() / 2 - 4).attr("width", 8).attr("height", 8)
            .attr("fill", d => d.featureName.includes('AS') ? window.APP_CONFIG.CHART_SETTINGS.AS_COLOR : window.APP_CONFIG.CHART_SETTINGS.T2_COLOR)
            .on("mouseover", (event, d) => {
                tooltip.transition().duration(50).style("opacity", .95);
                tooltip.html(getInterpretationTooltip('or', {...d.or, featureName: escapeHTML(d.featureName)}))
                    .style("left", (event.pageX + 10) + "px").style("top", (event.pageY - 15) + "px");
            })
            .on("mouseout", () => {
                tooltip.transition().duration(200).style("opacity", 0);
            });
    }

    // --- NEW: Box-Plot Implementation ---
    function renderBoxPlot(data, targetElementId, options = {}) {
        const setupOptions = { ...options, margin: { top: 20, right: 20, bottom: 40, left: 50, ...options.margin } };
        const containerSetup = createSvgContainer(targetElementId, setupOptions);
        if (!containerSetup) return;
        const { svg, chartArea, innerWidth, innerHeight, margin } = containerSetup;
        const tooltip = createTooltip();

        // data format: [{ label: 'N+', values: [...] }, { label: 'N-', values: [...] }]
        if (!Array.isArray(data) || data.length === 0) {
            chartArea.append('text').attr('x', innerWidth / 2).attr('y', innerHeight / 2).attr('text-anchor', 'middle').attr('class', 'text-muted small').text('No data for Box Plot.');
            return;
        }

        // Calculate stats for each group
        const statsData = data.map(group => {
            if (!group.values || group.values.length === 0) return { label: group.label, empty: true };
            const sorted = group.values.filter(v => typeof v === 'number' && isFinite(v)).sort(d3.ascending);
            if (sorted.length === 0) return { label: group.label, empty: true };
            
            const q1 = d3.quantile(sorted, 0.25);
            const median = d3.quantile(sorted, 0.5);
            const q3 = d3.quantile(sorted, 0.75);
            const iqr = q3 - q1;
            const minLimit = q1 - 1.5 * iqr;
            const maxLimit = q3 + 1.5 * iqr;
            
            // Find outliers
            const outliers = sorted.filter(v => v < minLimit || v > maxLimit);
            
            // Adjust min/max whiskers to data within limits
            const whiskerMin = d3.min(sorted.filter(v => v >= minLimit));
            const whiskerMax = d3.max(sorted.filter(v => v <= maxLimit));

            return { label: group.label, q1, median, q3, whiskerMin, whiskerMax, outliers, n: sorted.length };
        });

        const allValues = data.flatMap(d => d.values || []);
        const yMax = d3.max(allValues);
        const y = d3.scaleLinear().domain([0, yMax ? yMax * 1.1 : 10]).range([innerHeight, 0]).nice();
        const x = d3.scaleBand().range([0, innerWidth]).domain(statsData.map(d => d.label)).padding(0.4);

        // Gridlines
        if (window.APP_CONFIG.CHART_SETTINGS.ENABLE_GRIDLINES) {
            chartArea.append("g").attr("class", "grid y-grid").call(d3.axisLeft(y).tickSize(-innerWidth).tickFormat(""));
        }

        // Axes
        chartArea.append("g").attr("class", "y-axis axis").call(d3.axisLeft(y));
        chartArea.append("g").attr("class", "x-axis axis").attr("transform", `translate(0,${innerHeight})`).call(d3.axisBottom(x));
        
        svg.append("text").attr("class", "axis-label y-axis-label").attr("text-anchor", "middle")
            .attr("transform", `translate(${margin.left / 2}, ${margin.top + innerHeight / 2}) rotate(-90)`)
            .style("font-size", window.APP_CONFIG.CHART_SETTINGS.AXIS_LABEL_FONT_SIZE)
            .text(window.APP_CONFIG.UI_TEXTS.axisLabels.size);

        // Draw boxes
        const boxGroups = chartArea.selectAll(".box-group").data(statsData).join("g")
            .attr("class", "box-group").attr("transform", d => `translate(${x(d.label)},0)`);

        boxGroups.each(function(d) {
            if (d.empty) return;
            const g = d3.select(this);
            const width = x.bandwidth();
            const center = width / 2;
            const color = (d.label.includes('N+') || d.label.includes('AS+')) ? window.APP_CONFIG.CHART_SETTINGS.N_POS_COLOR : window.APP_CONFIG.CHART_SETTINGS.N_NEG_COLOR;

            // Vertical line (whisker range)
            g.append("line").attr("x1", center).attr("x2", center)
                .attr("y1", y(d.whiskerMin)).attr("y2", y(d.whiskerMax))
                .attr("stroke", "#333").attr("stroke-width", 1);

            // Box
            g.append("rect").attr("x", 0).attr("y", y(d.q3))
                .attr("height", y(d.q1) - y(d.q3)).attr("width", width)
                .attr("stroke", "#333").attr("stroke-width", 1)
                .attr("fill", color).style("opacity", 0.7)
                .on("mouseover", (event) => {
                    tooltip.transition().duration(50).style("opacity", .95);
                    tooltip.html(`<strong>${d.label}</strong> (n=${d.n})<br>Median: ${formatNumber(d.median, 1)}<br>IQR: ${formatNumber(d.q1, 1)} - ${formatNumber(d.q3, 1)}<br>Range (excl. outliers): ${formatNumber(d.whiskerMin, 1)} - ${formatNumber(d.whiskerMax, 1)}`)
                        .style("left", (event.pageX + 10) + "px").style("top", (event.pageY - 15) + "px");
                })
                .on("mouseout", () => {
                    tooltip.transition().duration(200).style("opacity", 0);
                });

            // Median line
            g.append("line").attr("x1", 0).attr("x2", width)
                .attr("y1", y(d.median)).attr("y2", y(d.median))
                .attr("stroke", "#333").attr("stroke-width", 2);
            
            // Whisker caps
            g.append("line").attr("x1", center - width/4).attr("x2", center + width/4).attr("y1", y(d.whiskerMin)).attr("y2", y(d.whiskerMin)).attr("stroke", "#333");
            g.append("line").attr("x1", center - width/4).attr("x2", center + width/4).attr("y1", y(d.whiskerMax)).attr("y2", y(d.whiskerMax)).attr("stroke", "#333");

            // Outliers
            g.selectAll(".outlier").data(d.outliers).join("circle")
                .attr("class", "outlier").attr("cx", center).attr("cy", v => y(v)).attr("r", 3)
                .style("fill", "none").style("stroke", "#333").style("opacity", 0.6);
        });
    }

    // --- NEW: Grouped Histogram Implementation ---
    function renderGroupedHistogram(data, targetElementId, options = {}) {
        // data: [{ label: 'N+', values: [...] }, { label: 'N-', values: [...] }]
        const setupOptions = { ...options, margin: { top: 20, right: 20, bottom: 50, left: 50, ...options.margin }, legendBelow: true, legendItemCount: data.length };
        const containerSetup = createSvgContainer(targetElementId, setupOptions);
        if (!containerSetup) return;
        const { svg, chartArea, innerWidth, innerHeight, margin, height, legendSpaceY } = containerSetup;
        const tooltip = createTooltip();

        const allValues = data.flatMap(d => d.values || []).filter(v => typeof v === 'number' && isFinite(v));
        if (allValues.length === 0) {
            chartArea.append('text').attr('x', innerWidth / 2).attr('y', innerHeight / 2).attr('text-anchor', 'middle').attr('class', 'text-muted small').text('No data for Histogram.');
            return;
        }

        const xMax = Math.ceil(d3.max(allValues)) || 10;
        const x = d3.scaleLinear().domain([0, xMax]).range([0, innerWidth]).nice();
        
        const histogram = d3.histogram().domain(x.domain()).thresholds(x.ticks(20));
        
        const binsData = data.map(group => ({
            label: group.label,
            bins: histogram(group.values || [])
        }));

        const yMax = d3.max(binsData, d => d3.max(d.bins, bin => bin.length)) || 1;
        const y = d3.scaleLinear().domain([0, yMax]).range([innerHeight, 0]).nice();

        const colorScale = d3.scaleOrdinal()
            .domain(['N+', 'N-', 'AS+', 'AS-'])
            .range([window.APP_CONFIG.CHART_SETTINGS.N_POS_COLOR, window.APP_CONFIG.CHART_SETTINGS.N_NEG_COLOR, window.APP_CONFIG.CHART_SETTINGS.AS_COLOR, '#ff7f0e']);

        if (window.APP_CONFIG.CHART_SETTINGS.ENABLE_GRIDLINES) {
            chartArea.append("g").attr("class", "grid y-grid").call(d3.axisLeft(y).tickSize(-innerWidth).tickFormat(""));
        }

        chartArea.append("g").attr("class", "x-axis axis").attr("transform", `translate(0,${innerHeight})`).call(d3.axisBottom(x));
        chartArea.append("g").attr("class", "y-axis axis").call(d3.axisLeft(y));

        svg.append("text").attr("class", "axis-label x-axis-label").attr("text-anchor", "middle")
            .attr("x", margin.left + innerWidth / 2).attr("y", height - legendSpaceY - 5)
            .style("font-size", window.APP_CONFIG.CHART_SETTINGS.AXIS_LABEL_FONT_SIZE).text(window.APP_CONFIG.UI_TEXTS.axisLabels.size);
        
        svg.append("text").attr("class", "axis-label y-axis-label").attr("text-anchor", "middle")
            .attr("transform", `translate(${margin.left / 2}, ${margin.top + innerHeight / 2}) rotate(-90)`)
            .style("font-size", window.APP_CONFIG.CHART_SETTINGS.AXIS_LABEL_FONT_SIZE).text(window.APP_CONFIG.UI_TEXTS.axisLabels.frequency);

        // Draw overlapping histograms (using opacity)
        // Or grouped bars. Overlapping is standard for distributions.
        
        binsData.forEach(group => {
            chartArea.selectAll(`.bar-${group.label.replace(/[^a-zA-Z0-9]/g, '')}`)
                .data(group.bins)
                .join("rect")
                .attr("x", d => x(d.x0) + 1)
                .attr("width", d => Math.max(0, x(d.x1) - x(d.x0) - 1))
                .attr("y", d => y(d.length))
                .attr("height", d => innerHeight - y(d.length))
                .style("fill", colorScale(group.label))
                .style("opacity", 0.5)
                .style("mix-blend-mode", "multiply")
                .on("mouseover", (event, d) => {
                    tooltip.transition().duration(50).style("opacity", .95);
                    tooltip.html(`<strong>${group.label}</strong><br>Size: ${d.x0}-${d.x1} mm<br>Count: ${d.length}`)
                        .style("left", (event.pageX + 10) + "px").style("top", (event.pageY - 15) + "px");
                    d3.select(event.currentTarget).style("opacity", 0.8).style("stroke", "#333");
                })
                .on("mouseout", (event) => {
                    tooltip.transition().duration(200).style("opacity", 0);
                    d3.select(event.currentTarget).style("opacity", 0.5).style("stroke", "none");
                });
        });

        // Legend
        if (options.legendBelow) {
            const legend = svg.append("g").attr("class", "legend")
                .attr("transform", `translate(${margin.left}, ${height - legendSpaceY + 15})`);
            
            let xOffset = 0;
            data.forEach(group => {
                const item = legend.append("g").attr("transform", `translate(${xOffset}, 0)`);
                item.append("rect").attr("width", 10).attr("height", 10).attr("fill", colorScale(group.label)).style("opacity", 0.5);
                item.append("text").attr("x", 15).attr("y", 9).text(group.label).style("font-size", "11px");
                xOffset += 50;
            });
        }
    }

    // --- NEW: Size Stratified Performance Chart ---
    function renderSizePerformanceChart(data, targetElementId, options = {}) {
        // data: [{ category: '<5mm', metrics: { sens: 0.8, spec: 0.9, auc: 0.75 } }, ...]
        const setupOptions = { ...options, margin: { top: 20, right: 20, bottom: 60, left: 50, ...options.margin }, legendBelow: true, legendItemCount: 3 };
        const containerSetup = createSvgContainer(targetElementId, setupOptions);
        if (!containerSetup) return;
        const { svg, chartArea, innerWidth, innerHeight, margin, height, legendSpaceY } = containerSetup;
        const tooltip = createTooltip();

        if (!Array.isArray(data) || data.length === 0) return;

        const categories = data.map(d => d.category);
        const metricKeys = ['sens', 'spec', 'auc']; // Standard metrics to show
        
        const x0 = d3.scaleBand().domain(categories).range([0, innerWidth]).paddingInner(0.2);
        const x1 = d3.scaleBand().domain(metricKeys).range([0, x0.bandwidth()]).padding(0.05);
        const y = d3.scaleLinear().domain([0, 1]).nice().range([innerHeight, 0]);
        const color = d3.scaleOrdinal().domain(metricKeys).range(['#4c78a8', '#f58518', '#e45756']); // Tableau10 simplified

        chartArea.append("g").attr("class", "y-axis axis").call(d3.axisLeft(y).ticks(5, "%"));
        chartArea.append("g").attr("class", "x-axis axis").attr("transform", `translate(0,${innerHeight})`).call(d3.axisBottom(x0));

        if (window.APP_CONFIG.CHART_SETTINGS.ENABLE_GRIDLINES) {
            chartArea.append("g").attr("class", "grid y-grid").call(d3.axisLeft(y).tickSize(-innerWidth).tickFormat(""));
        }

        const categoryGroup = chartArea.selectAll(".cat-group").data(data).join("g")
            .attr("transform", d => `translate(${x0(d.category)},0)`);

        categoryGroup.selectAll("rect").data(d => metricKeys.map(k => ({ key: k, value: d.metrics[k]?.value, category: d.category })))
            .join("rect")
            .attr("x", d => x1(d.key))
            .attr("y", d => y(d.value || 0))
            .attr("width", x1.bandwidth())
            .attr("height", d => innerHeight - y(d.value || 0))
            .attr("fill", d => color(d.key))
            .on("mouseover", (event, d) => {
                tooltip.transition().duration(50).style("opacity", .95);
                const val = d.key === 'auc' ? formatNumber(d.value, 3) : formatPercent(d.value, 1);
                tooltip.html(`<strong>${d.category}</strong><br>${d.key.toUpperCase()}: ${val}`)
                    .style("left", (event.pageX + 10) + "px").style("top", (event.pageY - 15) + "px");
                d3.select(event.currentTarget).style("opacity", 0.8);
            })
            .on("mouseout", (event) => {
                tooltip.transition().duration(200).style("opacity", 0);
                d3.select(event.currentTarget).style("opacity", 1);
            });

        // Legend
        if (options.legendBelow) {
            const legend = svg.append("g").attr("class", "legend")
                .attr("transform", `translate(${margin.left}, ${height - legendSpaceY + 15})`);
            
            let xOffset = 0;
            metricKeys.forEach(key => {
                const item = legend.append("g").attr("transform", `translate(${xOffset}, 0)`);
                item.append("rect").attr("width", 10).attr("height", 10).attr("fill", color(key));
                item.append("text").attr("x", 15).attr("y", 9).text(key.toUpperCase()).style("font-size", "11px");
                xOffset += 60;
            });
        }
    }

    return Object.freeze({
        renderAgeDistributionChart,
        renderPieChart,
        renderComparisonBarChart,
        renderDiagnosticPerformanceChart,
        renderFeatureImportanceChart,
        renderBoxPlot,
        renderGroupedHistogram,
        renderSizePerformanceChart,
        clearChartCache
    });

})();